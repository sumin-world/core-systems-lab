# Day 1: C Runtime & Dynamic Memory

## 1. Stack Frame Analysis
- Analyzed `main.s` generated by GCC using `-S -O0` flag.
- Identified Function Prologue: `push %rbp`, `mov %rsp, %rbp` - these instructions set up the stack frame by saving the old base pointer and establishing a new frame.
- Explanation of `_start` vs `main`: `_start` is the actual entry point of a C program provided by the C runtime library (CRT). It performs initialization (setting up argc/argv, environment variables, calling constructors) before calling `main()`. After `main()` returns, `_start` handles cleanup and calls `exit()` with the return value. `main()` is just a function called by the runtime, not the true program entry point.

## 2. Implementation: MyVector
- **Strategy:** Implemented lazy allocation (starting with NULL) and doubling capacity strategy (4 → 8 → 16 → ...) for O(1) amortized insertion cost.
- **Memory Safety:** 
  - Used temporary pointer for `realloc()` to prevent losing the original pointer on allocation failure
  - Checked all `malloc/realloc` return values with NULL checks
  - Set pointer to NULL after `free()` to prevent dangling pointer bugs
  - Ensured `free()` is called in `vector_free()` on program exit
- **Tools Used:** Vim for editing, GCC with `-Wall -Wextra -Werror -pedantic -std=c11 -g` flags for strict compilation, Valgrind for memory leak detection.

## 3. Issues & Resolutions

### Issue 1: Pointer vs Value Confusion
- **Problem:** Initially confused when to use `.` vs `->` for struct member access, and when to use `&` operator.
- **Resolution:** Learned that in `main()`, `MyVector v` is a variable (not pointer), so use `v.capacity` with dot notation. When passing to functions that expect `MyVector *`, use `&v` to pass the address. Inside functions receiving `MyVector *v`, use `v->capacity` with arrow notation.

### Issue 2: realloc Safety
- **Problem:** Initially wrote `v->data = realloc(v->data, new_size)` which would lose the original pointer if realloc fails (returns NULL).
- **Resolution:** Used temporary pointer pattern: `int *temp = realloc(v->data, new_size); if (temp == NULL) { handle_error; } else { v->data = temp; }` to preserve original pointer on failure.

### Issue 3: Boundary Condition in vector_get
- **Problem:** Initially used `if (index > v->size)` which would allow `index == size`, accessing uninitialized memory.
- **Resolution:** Changed to `if (index >= v->size)` since valid indices are 0 to size-1.

### Issue 4: Understanding Header File Organization
- **Problem:** Confused about why files are split into `.h` and `.c`, and what order to include headers.
- **Resolution:** Learned that `.h` files are interfaces (declarations), `.c` files are implementations. In implementation files (`my_vector.c`), include own header first to test self-sufficiency. In user files (`main.c`), include system headers before project headers. Used include guards (`#ifndef MY_VECTOR_H`) to prevent multiple inclusion.

### Issue 5: sizeof in Memory Allocation
- **Problem:** Forgot to multiply by `sizeof(int)` in realloc call initially.
- **Resolution:** Remembered that `malloc/realloc` expect byte count, not element count. Always use `capacity * sizeof(int)` for int arrays.